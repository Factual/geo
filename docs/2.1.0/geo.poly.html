<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>geo.poly documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Geo</span> <span class="project-version">2.1.0</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>geo</span></div></div></li><li class="depth-2 branch"><a href="geo.crs.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>crs</span></div></a></li><li class="depth-2 branch"><a href="geo.geohash.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>geohash</span></div></a></li><li class="depth-2 branch"><a href="geo.h3.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>h3</span></div></a></li><li class="depth-2 branch"><a href="geo.io.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>io</span></div></a></li><li class="depth-2 branch"><a href="geo.jts.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jts</span></div></a></li><li class="depth-2 branch current"><a href="geo.poly.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>poly</span></div></a></li><li class="depth-2"><a href="geo.spatial.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>spatial</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="geo.poly.html#var-bisect-region"><div class="inner"><span>bisect-region</span></div></a></li><li class="depth-1"><a href="geo.poly.html#var-bounded-space-partition"><div class="inner"><span>bounded-space-partition</span></div></a></li><li class="depth-1"><a href="geo.poly.html#var-box-contains.3F"><div class="inner"><span>box-contains?</span></div></a></li><li class="depth-1"><a href="geo.poly.html#var-boxes-intersect.3F"><div class="inner"><span>boxes-intersect?</span></div></a></li><li class="depth-1"><a href="geo.poly.html#var-degenerate.3F"><div class="inner"><span>degenerate?</span></div></a></li><li class="depth-1"><a href="geo.poly.html#var-dist.C2.B2"><div class="inner"><span>dist²</span></div></a></li><li class="depth-1"><a href="geo.poly.html#var-dot"><div class="inner"><span>dot</span></div></a></li><li class="depth-1"><a href="geo.poly.html#var-edge-intersection"><div class="inner"><span>edge-intersection</span></div></a></li><li class="depth-1"><a href="geo.poly.html#var-edges-.3Eregion"><div class="inner"><span>edges-&gt;region</span></div></a></li><li class="depth-1"><a href="geo.poly.html#var-edges-intersect.3F"><div class="inner"><span>edges-intersect?</span></div></a></li><li class="depth-1"><a href="geo.poly.html#var-EPSILON"><div class="inner"><span>EPSILON</span></div></a></li><li class="depth-1"><a href="geo.poly.html#var-line-contains.3F"><div class="inner"><span>line-contains?</span></div></a></li><li class="depth-1"><a href="geo.poly.html#var-line-coordinate"><div class="inner"><span>line-coordinate</span></div></a></li><li class="depth-1"><a href="geo.poly.html#var-minus"><div class="inner"><span>minus</span></div></a></li><li class="depth-1"><a href="geo.poly.html#var-normal"><div class="inner"><span>normal</span></div></a></li><li class="depth-1"><a href="geo.poly.html#var-partitioned-poly-contains.3F"><div class="inner"><span>partitioned-poly-contains?</span></div></a></li><li class="depth-1"><a href="geo.poly.html#var-partitioned-poly-intersects.3F"><div class="inner"><span>partitioned-poly-intersects?</span></div></a></li><li class="depth-1"><a href="geo.poly.html#var-plus*"><div class="inner"><span>plus*</span></div></a></li><li class="depth-1"><a href="geo.poly.html#var-poly-contains.3F"><div class="inner"><span>poly-contains?</span></div></a></li><li class="depth-1"><a href="geo.poly.html#var-positive-side.3F"><div class="inner"><span>positive-side?</span></div></a></li><li class="depth-1"><a href="geo.poly.html#var-region-bounding-box"><div class="inner"><span>region-bounding-box</span></div></a></li><li class="depth-1"><a href="geo.poly.html#var-region-contains.3F"><div class="inner"><span>region-contains?</span></div></a></li><li class="depth-1"><a href="geo.poly.html#var-region-edges"><div class="inner"><span>region-edges</span></div></a></li><li class="depth-1"><a href="geo.poly.html#var-single-poly-contains.3F"><div class="inner"><span>single-poly-contains?</span></div></a></li><li class="depth-1"><a href="geo.poly.html#var-split-edge"><div class="inner"><span>split-edge</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">geo.poly</h1><div class="doc"><pre class="plaintext">Polygon operations: primarily intersection testing, point-contains,
polygon-&gt;edges, bounding boxes, normal vectors, linear coordinates,
bisections, box intersections, bounded-space partitioning, and so on.</pre></div><div class="public anchor" id="var-bisect-region"><h3>bisect-region</h3><div class="usage"><code>(bisect-region region)</code></div><div class="doc"><pre class="plaintext">Takes a region and returns two new regions, each representing one side of the axis-aligned
bisection of the original. Any edge crossing the bisecting line is split, and any gaps created by
bisection are filled by using segments from the bisecting line.</pre></div></div><div class="public anchor" id="var-bounded-space-partition"><h3>bounded-space-partition</h3><div class="usage"><code>(bounded-space-partition region max-edge-length)</code></div><div class="doc"><pre class="plaintext">Returns an indexed structure that can be used to test points. The structure is repeatedly
bisected until each dimension is smaller than the given amount.</pre></div></div><div class="public anchor" id="var-box-contains.3F"><h3>box-contains?</h3><div class="usage"><code>(box-contains? [[minlat minlng] [maxlat maxlng]] [lat lng])</code></div><div class="doc"><pre class="plaintext">Returns true if a bounding box contains the given point.
</pre></div></div><div class="public anchor" id="var-boxes-intersect.3F"><h3>boxes-intersect?</h3><div class="usage"><code>(boxes-intersect? [[x11 y11] [x12 y12]] [[x21 y21] [x22 y22]])</code></div><div class="doc"><pre class="plaintext">Returns true if two bounding boxes contain any common area. (Algorithm from
<a href="http://stackoverflow.com/questions/306316/determine-if-two-rectangles-overlap-each-other)">http://stackoverflow.com/questions/306316/determine-if-two-rectangles-overlap-each-other)</a></pre></div></div><div class="public anchor" id="var-degenerate.3F"><h3>degenerate?</h3><div class="usage"><code>(degenerate? p1 p2)</code></div><div class="doc"><pre class="plaintext">Returns true if the edge's points are identical (i.e. the edge has no length).
</pre></div></div><div class="public anchor" id="var-dist.C2.B2"><h3>dist²</h3><div class="usage"><code>(dist² v)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-dot"><h3>dot</h3><div class="usage"><code>(dot [x1 y1] [x2 y2])</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-edge-intersection"><h3>edge-intersection</h3><div class="usage"><code>(edge-intersection [p11 p12] [p21 p22])</code></div><div class="doc"><pre class="plaintext">Returns the point of intersection of two edges. Behavior is undefined if the edges do not
intersect (use edges-intersect? to test), or if the two lines are parallel.</pre></div></div><div class="public anchor" id="var-edges-.3Eregion"><h3>edges-&gt;region</h3><div class="usage"><code>(edges-&gt;region bisecting-line edges)</code></div><div class="doc"><pre class="plaintext">Combines edges to form a new region. The bisecting line is required here because we need to infer
edges where there are gaps.</pre></div></div><div class="public anchor" id="var-edges-intersect.3F"><h3>edges-intersect?</h3><div class="usage"><code>(edges-intersect? [p11 p12 :as e1] [p21 p22 :as e2])</code></div><div class="doc"><pre class="plaintext">Returns true if two edges intersect.
</pre></div></div><div class="public anchor" id="var-EPSILON"><h3>EPSILON</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-line-contains.3F"><h3>line-contains?</h3><div class="usage"><code>(line-contains? [p1 p2] p)</code></div><div class="doc"><pre class="plaintext">Returns true if a line contains a point.
</pre></div></div><div class="public anchor" id="var-line-coordinate"><h3>line-coordinate</h3><div class="usage"><code>(line-coordinate [p1 p2] p)</code></div><div class="doc"><pre class="plaintext">Returns the line-coordinate of the given point. Works best when the point is on the line.
</pre></div></div><div class="public anchor" id="var-minus"><h3>minus</h3><div class="usage"><code>(minus [x1 y1] [x2 y2])</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-normal"><h3>normal</h3><div class="usage"><code>(normal [x1 y1] [x2 y2])</code></div><div class="doc"><pre class="plaintext">Returns a normal vector for the given line. You can then take the dot product of points against
this vector to see which side of the line they are on.</pre></div></div><div class="public anchor" id="var-partitioned-poly-contains.3F"><h3>partitioned-poly-contains?</h3><div class="usage"><code>(partitioned-poly-contains? partitioned-poly p)</code></div><div class="doc"><pre class="plaintext">Returns true if the partitioned poly contains the given point.
</pre></div></div><div class="public anchor" id="var-partitioned-poly-intersects.3F"><h3>partitioned-poly-intersects?</h3><div class="usage"><code>(partitioned-poly-intersects? partitioned-poly box)</code></div><div class="doc"><pre class="plaintext">Returns true if the partitioned polygon intersects the given box. The poly must be partitioned
such that the bounding boxes end up being no larger than the one being tested for.</pre></div></div><div class="public anchor" id="var-plus*"><h3>plus*</h3><div class="usage"><code>(plus* [x y] [dx dy] factor)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-poly-contains.3F"><h3>poly-contains?</h3><div class="usage"><code>(poly-contains? lat lng poly)</code></div><div class="doc"><pre class="plaintext">Used for implicitly-closed polys. Count the number of side-intersections for a ray extending from
[lat, ∞]; if even, the point is outside.

poly should be of this form:

[[[lat1 lng1 lat2 lng2 ... latk lngk] [latk+1 lngk+1 ... ]]   ; one poly with a hole
 [[latj lngj latj+1 lngj+1 ...] ...]                          ; another poly with a hole
 ...]

Specifically:

[[[&amp; include] [&amp; exclude] [&amp; exclude] ...]
 [[&amp; include] [&amp; exclude] ...]
 ...]

The toplevel array is considered to be the union of its elements.</pre></div></div><div class="public anchor" id="var-positive-side.3F"><h3>positive-side?</h3><div class="usage"><code>(positive-side? [p1 p2] p)</code></div><div class="doc"><pre class="plaintext">Returns true if the given point is on the "positive side" of the line. Positive and negative
sides are deterministic and consistent, so you can use this with a line to partition space.</pre></div></div><div class="public anchor" id="var-region-bounding-box"><h3>region-bounding-box</h3><div class="usage"><code>(region-bounding-box region)</code></div><div class="doc"><pre class="plaintext">Returns a bounding box for the given region. The bounding box is returned as [[minlat minlng]
[maxlat maxlng]].</pre></div></div><div class="public anchor" id="var-region-contains.3F"><h3>region-contains?</h3><div class="usage"><code>(region-contains? lat lng points)</code></div><div class="doc"><pre class="plaintext">Returns true if the bounded region contains the point. The region need not
be convex, and its edges may intersect. It must contain at least three
points. Algorithm from
<a href="http://stackoverflow.com/questions/217578/point-in-polygon-aka-hit-test">http://stackoverflow.com/questions/217578/point-in-polygon-aka-hit-test</a>.

This would normally be written as a reduction, but the first/last points wrap
around.</pre></div></div><div class="public anchor" id="var-region-edges"><h3>region-edges</h3><div class="usage"><code>(region-edges region)</code></div><div class="doc"><pre class="plaintext">Returns a list of [[lat1 lng1] [lat2 lng2]], each of which describes an edge of the region. The
region is implicitly closed.</pre></div></div><div class="public anchor" id="var-single-poly-contains.3F"><h3>single-poly-contains?</h3><div class="usage"><code>(single-poly-contains? lat lng [include &amp; exclude])</code></div><div class="doc"><pre class="plaintext">Uses edge intersection testing to determine whether a single bounded shape
contains the given point.</pre></div></div><div class="public anchor" id="var-split-edge"><h3>split-edge</h3><div class="usage"><code>(split-edge line [p1 p2 :as edge])</code></div><div class="doc"><pre class="plaintext">Takes a line and an edge, and returns two new edges, the first of which is on the positive side
of the line and the second of which is on the negative side. The line and the edge must
intersect.</pre></div></div></div></body></html>